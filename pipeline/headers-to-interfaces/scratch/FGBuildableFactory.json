[
  {
    "kind": "enum",
    "name": "EProductionStatus",
    "comment": "Production status of the factory, i.e. displayed on the indicator.",
    "entries": [
      {
        "name": "IS_NONE"
      },
      {
        "name": "IS_PRODUCING"
      },
      {
        "name": "IS_PRODUCING_WITH_CRYSTAL",
        "comment": "We have a crystal in the potential slot and are producing"
      },
      {
        "name": "IS_STANDBY"
      },
      {
        "name": "IS_ERROR"
      },
      {
        "name": "IS_MAX"
      }
    ]
  },
  {
    "kind": "class",
    "name": "AFGBuildableFactory",
    "category": "UCLASS",
    "comment": "Base class for factory machines like miners, conveyors, assemblers, storages etc.\n@todorefactor Comments about the Factory_ and non factory code.",
    "extends": [
      "AFGBuildable",
      "IFGSignificanceInterface",
      "IFGReplicationDetailActorOwnerInterface"
    ],
    "methods": [
      {
        "name": "AFGBuildableFactory"
      },
      {
        "name": "GetLifetimeReplicatedProps",
        "comment": "Replication",
        "returnType": "void"
      },
      {
        "name": "PreReplication",
        "returnType": "void"
      },
      {
        "name": "GetNetDormancy",
        "returnType": "bool"
      },
      {
        "name": "BeginPlay",
        "comment": "Begin AActor interface",
        "returnType": "void"
      },
      {
        "name": "EndPlay",
        "returnType": "void"
      },
      {
        "name": "Tick",
        "returnType": "void"
      },
      {
        "name": "PreSaveGame_Implementation",
        "comment": "Begin IFGSaveInterface",
        "returnType": "void"
      },
      {
        "name": "GainedSignificance_Implementation",
        "comment": "Begin IFGSignificanceInterface",
        "returnType": "void"
      },
      {
        "name": "LostSignificance_Implementation",
        "returnType": "void"
      },
      {
        "name": "GetSignificanceBias",
        "returnType": "float"
      },
      {
        "name": "GetSignificanceRange",
        "returnType": "float"
      },
      {
        "name": "GainedSignificance_Native",
        "returnType": "void"
      },
      {
        "name": "LostSignificance_Native",
        "returnType": "void"
      },
      {
        "name": "SetupForSignificance",
        "returnType": "void"
      },
      {
        "name": "Factory_Tick",
        "comment": "Begin Factory_ interface",
        "returnType": "void"
      },
      {
        "name": "GetDismantleRefund_Implementation",
        "comment": "Begin IFGDismantleInterface",
        "returnType": "void"
      },
      {
        "name": "GetReplicationDetailActor",
        "comment": "Begin IFGReplicationDetailActorOwnerInterface",
        "returnType": "AFGReplicationDetailActor*"
      },
      {
        "name": "OnBuildableReplicationDetailStateChange",
        "returnType": "void"
      },
      {
        "name": "OnReplicationDetailActorCreated",
        "returnType": "void"
      },
      {
        "name": "GetReplicationDetailActorClass",
        "returnType": "UClass*"
      },
      {
        "name": "ShouldSkipBuildEffect",
        "comment": "Begin FGBuildable",
        "returnType": "bool"
      },
      {
        "name": "GetConnectionComponents",
        "comment": "Get the connections to this factory.",
        "returnType": "TArray<UFGFactoryConnectionComponent*>"
      },
      {
        "name": "HasPower",
        "comment": "Check if we have power.\n@return true if we have power; false if we do not have power or does not run on power.",
        "returnType": "bool"
      },
      {
        "name": "RunsOnPower",
        "comment": "Check if this machine runs on power.\n@return - true if this machine runs on power; false if it does not.",
        "returnType": "bool"
      },
      {
        "name": "GetPowerInfo",
        "comment": "Get the power info for this factory.\n@return The power info for this factory; nullptr if this factory does not run on power.",
        "returnType": "classUFGPowerInfoComponent*"
      },
      {
        "name": "GetIdlePowerConsumption",
        "comment": "Get the power consumption for production.",
        "returnType": "float"
      },
      {
        "name": "GetProducingPowerConsumption",
        "comment": "The power consumption when producing.",
        "returnType": "float"
      },
      {
        "name": "GetDefaultProducingPowerConsumption",
        "comment": "The unmodified power consumption when producing.",
        "returnType": "float"
      },
      {
        "name": "CalcProducingPowerConsumptionForPotential",
        "comment": "Helper to get the power consumption for production at a certain potential.",
        "returnType": "float"
      },
      {
        "name": "IsConfigured",
        "comment": "Check if this building has been configured by the player, has recipe set etc.",
        "returnType": "bool"
      },
      {
        "name": "IsProducing",
        "comment": "\n @return - true if producing; otherwise false.",
        "returnType": "bool"
      },
      {
        "name": "CanProduce",
        "comment": "\n @return - true if we can start production; otherwise false.",
        "returnType": "bool"
      },
      {
        "name": "SetIsProductionPaused",
        "comment": "Set if this factory should pause it's production or not.",
        "returnType": "void"
      },
      {
        "name": "IsProductionPaused",
        "comment": "Is this factory's production manually paused.",
        "returnType": "bool"
      },
      {
        "name": "GetProductionIndicatorStatus",
        "comment": "@todomods This should be moddable without performance impact.\n@return The status to display on the production indicator.",
        "returnType": "EProductionStatus"
      },
      {
        "name": "GetProductionProgress",
        "comment": "Returns the current progress of the production.",
        "returnType": "float"
      },
      {
        "name": "GetProductionCycleTime",
        "comment": "The current production cycle time for the current recipe with modifiers.",
        "returnType": "float"
      },
      {
        "name": "GetDefaultProductionCycleTime",
        "comment": "The unmodified production cycle time for the current recipe.",
        "returnType": "float"
      },
      {
        "name": "GetProductionCycleTimeForRecipe",
        "comment": "Calculates the production cycle time of this factory with a certain recipe without modifiers.",
        "returnType": "float"
      },
      {
        "name": "CalcProductionCycleTimeForPotential",
        "comment": "Calculates the production cycle time of this factory with a certain potential",
        "returnType": "float"
      },
      {
        "name": "GetProductivity",
        "comment": "A measure of how productive this factory is.",
        "returnType": "float"
      },
      {
        "name": "GetPotentialInventory",
        "comment": "Get the inventory that we place crystal in to unlock the slider of potential",
        "returnType": "UFGInventoryComponent*"
      },
      {
        "name": "GetCurrentPotential",
        "comment": "Gets you the current potential",
        "returnType": "float"
      },
      {
        "name": "GetPendingPotential",
        "comment": "Gets you the pending potential",
        "returnType": "float"
      },
      {
        "name": "SetPendingPotential",
        "comment": "Set a new pending potential, the current one will be changed to this when we finish a production cycle",
        "returnType": "void"
      },
      {
        "name": "GetMinPotential",
        "comment": "Get the minimum potential possible",
        "returnType": "float"
      },
      {
        "name": "GetCurrentMaxPotential",
        "comment": "Get the maximum potential possible depending on the num crystals in inventories",
        "returnType": "float"
      },
      {
        "name": "GetMaxPossiblePotential",
        "comment": "Get the max potential, as if you had all slots filled with crystals",
        "returnType": "float"
      },
      {
        "name": "GetCanChangePotential",
        "comment": "Get mCanChangePotential",
        "returnType": "bool"
      },
      {
        "name": "GetFluidInventoryStackSizeScalar",
        "comment": "Get the stack size scalar for fluid types on this buildable ( this is only relevant to fluid inventories )",
        "returnType": "float"
      },
      {
        "name": "GetScaledFluidStackSize",
        "comment": "Get the override stack size scaled for fluid types. Specified in class / BP defaults",
        "returnType": "int32"
      },
      {
        "name": "GetIsSignificant",
        "returnType": "bool"
      },
      {
        "name": "StartProductionLoopEffects",
        "comment": "Called when we want the looping SFX/VFX for production to start\n@param didStartProducing - true if factory just started producing",
        "returnType": "void"
      },
      {
        "name": "StopProductionLoopEffects",
        "comment": "Called when we want the looping SFX/VFX for production to stop\n@param didStopProducing - true if the production stopped",
        "returnType": "void"
      },
      {
        "name": "StartIdlingLoopEffects",
        "comment": "Called when we want the looping SFX/VFX for idling ( power but no production ) to start\n@param didGainPower - true if factory just got power",
        "returnType": "void"
      },
      {
        "name": "StopIdlingLoopEffects",
        "comment": "Called when we want the looping SFX/VFX for idling ( power but no production ) to stop\n@param didLosePower - true if factory just lost power",
        "returnType": "void"
      },
      {
        "name": "TryStopIdlingLoopEffects",
        "comment": "Called when we want the looping SFX/VFX for idling ( power but no production ) to stop. Will prevent StopIdlingLoopEffects to be called twice in a row\n@param didLosePower - true if factory just got power",
        "returnType": "void"
      },
      {
        "name": "TryStartIdlingLoopEffects",
        "comment": "Called when we want the looping SFX/VFX for idling ( power but no production ) to start. Will prevent StartIdlingLoopEffects to be called twice in a row\n@param didGainPower - true if factory just got power",
        "returnType": "void"
      },
      {
        "name": "TryStartProductionLoopEffects",
        "comment": "Called when we want the looping SFX/VFX for production to stop. Will prevent StartProductionLoopEffects to be called twice in a row\n@param didStopProducing - true if the production stopped",
        "returnType": "void"
      },
      {
        "name": "TryStopProductionLoopEffects",
        "comment": "Called when we want the looping SFX/VFX for production to stop. Will prevent StopProductionLoopEffects to be called twice in a row\n@param didStopProducing - true if the production stopped",
        "returnType": "void"
      },
      {
        "name": "ShouldBeConsideredForBase_Implementation",
        "returnType": "bool"
      },
      {
        "name": "OnHasPowerChanged",
        "comment": "Called whenever HasPower has changed, exposed here for cleaner/more optimized ways of changing state when the factory has power",
        "returnType": "void"
      },
      {
        "name": "OnIsProducingChanged",
        "comment": "Called whenever IsProducing has changed, exposed here for cleaner/more optimized ways of changing state when the factory is producing",
        "returnType": "void"
      },
      {
        "name": "OnIsProducingChanged_Native",
        "comment": "Native version of OnIsProducingChanged",
        "returnType": "void"
      },
      {
        "name": "OnHasPowerChanged_Native",
        "comment": "Native version of OnHasPowerChanged",
        "returnType": "void"
      },
      {
        "name": "OnReplicatingDetailsChanged",
        "comment": "Begin AFGBuildable interface",
        "returnType": "void"
      },
      {
        "name": "Factory_ProductionCycleCompleted",
        "comment": "Call this when we finished a production cycle, like produced a recipe or extracted an ore.",
        "returnType": "void"
      },
      {
        "name": "Factory_CollectInput",
        "comment": "Try to collect input from connected buildings.",
        "returnType": "void"
      },
      {
        "name": "Factory_PullPipeInput",
        "comment": "Try to collect input from connected pipes",
        "returnType": "void"
      },
      {
        "name": "Factory_PushPipeOutput",
        "comment": "This is contrary to always pulling like FactoryConnections. Pipes are handled very differently from buildings\nso a push occurs so that each pipe doesn't need to differentiate between objects its connected to.",
        "returnType": "void"
      },
      {
        "name": "Factory_StartProducing",
        "comment": "Start the production, client get this call replicated after the server. You must call Super if overriding this.",
        "returnType": "void"
      },
      {
        "name": "Factory_ReceiveStartProducing",
        "comment": "Calls blueprint when we start producing.",
        "returnType": "void"
      },
      {
        "name": "Factory_TickProducing",
        "comment": "Tick the production.",
        "returnType": "void"
      },
      {
        "name": "Factory_TickProductivity",
        "comment": "Tick the fact that we are not producing. Used for productivity calculations.",
        "returnType": "void"
      },
      {
        "name": "Factory_ReceiveTickProducing",
        "comment": "Calls blueprint when we tick production.",
        "returnType": "void"
      },
      {
        "name": "Factory_StopProducing",
        "comment": "Stops the production, client get this call replicated after the server. You must call Super if overriding this.",
        "returnType": "void"
      },
      {
        "name": "Factory_ReceiveStopProducing",
        "comment": "Calls blueprint when we stop producing.",
        "returnType": "void"
      },
      {
        "name": "NativeUpdateEffects",
        "comment": "Function for updating sfx/vfx at intervals",
        "returnType": "void"
      },
      {
        "name": "ReceiveUpdateEffects",
        "comment": "Calls blueprint when we update effects.",
        "returnType": "void"
      },
      {
        "name": "OnRep_ReplicationDetailActor",
        "returnType": "void"
      },
      {
        "name": "GetOrCreateReplicationDetailActor",
        "returnType": "classAFGReplicationDetailActor*"
      },
      {
        "name": "OnRep_IsProducing",
        "comment": "Calls Start/Stop Producing on client",
        "returnType": "void"
      },
      {
        "name": "OnPotentialInventoryItemRemoved",
        "returnType": "void"
      },
      {
        "name": "GetCastRepDetailsActor",
        "comment": "@todo: make this a static function instead",
        "returnType": "classAFGReplicationDetailActor_BuildableFactory*"
      }
    ],
    "properties": [
      {
        "name": "mOnProductionStatusUpdateDeligate",
        "comment": "used for callback to vcchanged lites and such on indication objects",
        "type": "EProductionStatusUpdateDeligate"
      },
      {
        "name": "mPowerConsumption",
        "comment": "Power consumption of this factory.",
        "type": "float"
      },
      {
        "name": "mPowerConsumptionExponent",
        "comment": "Example: 2.5 ^ 1.6 = 4.33      An exponent of 1.6 gives a maximum consumption of 433% at 2.5x overclock.\nIf exponent is 1.0 the function becomes linear.",
        "type": "float"
      },
      {
        "name": "mPowerInfoClass",
        "comment": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
        "type": "TSubclassOf<classUFGPowerInfoComponent>"
      },
      {
        "name": "OnProductionStatusChange",
        "type": "staticEProductionStatusChange"
      },
      {
        "name": "mPowerInfo",
        "comment": "Power simulation info",
        "type": "classUFGPowerInfoComponent*"
      },
      {
        "name": "mOnHasPowerChanged",
        "comment": "So that you can listen for when power has changed",
        "type": "FBuildingStateChanged"
      },
      {
        "name": "mOnHasProductionChanged",
        "comment": "So that you can listen for when production has changed",
        "type": "FBuildingStateChanged"
      },
      {
        "name": "mMinimumProducingTime",
        "comment": "If the required input for the next part is available during this time, it starts producing again, thus remaining in the production state.\nTickProducing is not called during the wait.",
        "type": "float"
      },
      {
        "name": "mMinimumStoppedTime",
        "comment": "The minimum time that must pass from when the production is stopped until it can start up again.\nIf the machine has stopped and new parts are available within the delay, the machine will wait until the minimum time has passed.",
        "type": "float"
      },
      {
        "name": "mTimeSinceStartStopProducing",
        "comment": "This is reset every time the production is changed, i.e. StartProducing/StopProducing.",
        "type": "float"
      },
      {
        "name": "mNumCyclesForProductivity",
        "comment": "How many cycles back do we base the productivity on",
        "type": "int32"
      },
      {
        "name": "mCompletedCycleTimeStamps",
        "comment": "These are a list of timestamps for the most recently completed production cycles, used to calculate productivity",
        "type": "TArray<float>"
      },
      {
        "name": "mCurrentProductionCycleETA",
        "comment": "An estimation on when the current cycle will be done. If we didn't produce for a frame we add delta to this",
        "type": "float"
      },
      {
        "name": "mDidProduceThisTick",
        "comment": "Keeps track if we produced this tick or not",
        "type": "bool"
      },
      {
        "name": "mCanChangePotential",
        "comment": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
        "type": "bool"
      },
      {
        "name": "mCurrentPotential",
        "comment": "This is the current potential (overclock, overcharge) of this factory [0..N]",
        "type": "float"
      },
      {
        "name": "mPendingPotential",
        "comment": "When ever a production cycle is completed we set the current potential to this value",
        "type": "float"
      },
      {
        "name": "mMinPotential",
        "comment": "You can never set the potential to less than this when playing",
        "type": "float"
      },
      {
        "name": "mMaxPotential",
        "comment": "You can never set the potential to more than this when playing",
        "type": "float"
      },
      {
        "name": "mMaxPotentialIncreasePerCrystal",
        "comment": "When the player adds another crystal in the inventory we unlock even more potential",
        "type": "float"
      },
      {
        "name": "mFluidStackSizeDefault",
        "comment": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory",
        "type": "EStackSize"
      },
      {
        "name": "mFluidStackSizeMultiplier",
        "comment": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n FluidStackSize )",
        "type": "int32"
      },
      {
        "name": "mIsProductionPaused",
        "comment": "The player is able to toggle if production should be paused or not",
        "type": "bool"
      },
      {
        "name": "mReplicationDetailActor",
        "type": "classAFGReplicationDetailActor*"
      },
      {
        "name": "OnReplicationDetailActorCreatedEvent",
        "comment": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface.",
        "type": "FOnReplicationDetailActorCreated"
      },
      {
        "name": "mInventoryPotential",
        "comment": "The input we place a crystal in to unlock the potential",
        "type": "classUFGInventoryComponent*"
      },
      {
        "name": "mInventoryPotentialHandler",
        "type": "classUFGReplicationDetailInventoryComponent*"
      },
      {
        "name": "mSignificanceBias",
        "comment": "A bias to the significance value",
        "type": "float"
      },
      {
        "name": "mEffectUpdateInterval",
        "comment": "How often effect update should update",
        "type": "float"
      },
      {
        "name": "mEffectUpdateAccumulator",
        "comment": "Accumulator for the effect update interval",
        "type": "float"
      },
      {
        "name": "mCachedFluidStackSize",
        "comment": "Cached value of Fluid Resource Stack Size ( set in begin play from the default stack enum )",
        "type": "int32"
      },
      {
        "name": "mCurrentProductivity",
        "comment": "A replicated compressed version of the productivity",
        "type": "uint8"
      },
      {
        "name": "mIsProducing",
        "comment": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
        "type": "uint8"
      },
      {
        "name": "mHasCanProduce",
        "comment": "if true, then blueprint has implemented CanProduce",
        "type": "uint8"
      },
      {
        "name": "mHasPower",
        "comment": "If building has power, for more details about the circuitry see mPowerInfo.",
        "type": "uint8"
      },
      {
        "name": "mLastHasPower",
        "comment": "Last frame's has power",
        "type": "uint8"
      },
      {
        "name": "mLastIsProducing",
        "comment": "Last frame's is producing",
        "type": "uint8"
      },
      {
        "name": "mHasFactory_CollectInput",
        "comment": "if true, then blueprint has implemented Factory_CollectInput",
        "type": "uint8"
      },
      {
        "name": "mHasFactory_PullPipeInput",
        "comment": "if true, then the blueprint has implemented Factory_PullPipeInput",
        "type": "uint8"
      },
      {
        "name": "mHasFactory_PushPipeOutput",
        "comment": "if true, then the blueprint has implemented Factory_PushPipeOutput",
        "type": "uint8"
      },
      {
        "name": "mHasOnHasPowerChanged",
        "comment": "if true, then blueprint has implemented OnHasPowerChanged",
        "type": "uint8"
      },
      {
        "name": "mHasOnIsProducingChanged",
        "comment": "if true, then blueprint has implemented OnHasProducingChanged",
        "type": "uint8"
      },
      {
        "name": "mHasFactory_StartProducing",
        "comment": "if true, then blueprint has implemented Factory_StartProducing",
        "type": "uint8"
      },
      {
        "name": "mHasFactory_TickProducing",
        "comment": "if true, then blueprint has implemented Factory_TickProducing",
        "type": "uint8"
      },
      {
        "name": "mHasFactory_StopProducing",
        "comment": "if true, then blueprint has implemented Factory_StopProducing",
        "type": "uint8"
      },
      {
        "name": "mHasUpdateEffects",
        "comment": "if true, then blueprint has implemented UpdateEffects",
        "type": "uint8"
      },
      {
        "name": "mIsSignificant",
        "comment": "Indicates if the factory is within significance distance",
        "type": "uint8"
      },
      {
        "name": "mDidStartIdlingEffects",
        "comment": "Indicates if we have already started the idling effects",
        "type": "uint8"
      },
      {
        "name": "mDidStartProductionEffects",
        "comment": "Indicates if we have already started the production effects effects",
        "type": "uint8"
      },
      {
        "name": "mAddToSignificanceManager",
        "comment": "Indicates if the factory should be handled by significance manager",
        "type": "uint8"
      },
      {
        "name": "mSignificanceRange",
        "comment": "The range to keep the factory in significance",
        "type": "float"
      }
    ]
  }
]