[
  {
    "kind": "enum",
    "name": "EIgnore",
    "entries": [
      {
        "name": "I_NONE",
        "displayName": "Invalid status."
      },
      {
        "name": "I_FALSE",
        "displayName": "Target is not ignored."
      },
      {
        "name": "I_NOT_VALID",
        "displayName": "Target ignored cause not valid"
      },
      {
        "name": "I_NO_PATH",
        "displayName": "Target ignored cause could not find path."
      },
      {
        "name": "I_LastEnum"
      }
    ]
  },
  {
    "kind": "class",
    "name": "FAggroEntry",
    "category": "USTRUCT",
    "comment": "Contains information about how desirable a aggro\ntarget is for our Pawn",
    "extends": [],
    "methods": [
      {
        "name": "FAggroEntry",
        "comment": "Set good default values."
      },
      {
        "name": "FAggroEntry",
        "comment": "Set good default values."
      },
      {
        "name": "operator==",
        "returnType": "bool"
      }
    ],
    "properties": [
      {
        "name": "AggroTarget",
        "type": "TScriptInterface<IFGAggroTargetInterface>"
      },
      {
        "name": "BaseDesirability",
        "type": "float"
      },
      {
        "name": "Aggro",
        "type": "float"
      },
      {
        "name": "AggroDesirability",
        "type": "float"
      },
      {
        "name": "Distance",
        "type": "float"
      },
      {
        "name": "DistanceDesirability",
        "type": "float"
      },
      {
        "name": "LastHurtTime",
        "type": "float"
      },
      {
        "name": "Ignore",
        "type": "EIgnore"
      },
      {
        "name": "LastIgnoreTime",
        "type": "float"
      }
    ]
  },
  {
    "kind": "class",
    "name": "FFindByAggroTarget",
    "extends": [],
    "methods": [
      {
        "name": "FFindByAggroTarget"
      },
      {
        "name": "operator()",
        "returnType": "bool"
      }
    ],
    "properties": [
      {
        "name": "AggroTarget",
        "type": "TScriptInterface<IFGAggroTargetInterface>"
      }
    ]
  },
  {
    "kind": "class",
    "name": "AFGEnemyController",
    "category": "UCLASS",
    "extends": [
      "AFGCreatureController"
    ],
    "methods": [
      {
        "name": "AFGEnemyController",
        "comment": "ctor"
      },
      {
        "name": "OnPossess",
        "comment": "~ Begin AController Interface",
        "returnType": "void"
      },
      {
        "name": "OnUnPossess",
        "returnType": "void"
      },
      {
        "name": "StartPanic_Implementation",
        "comment": "Override the startpanic",
        "returnType": "void"
      },
      {
        "name": "RemoveAggroEntryByTarget",
        "comment": "Removes specified target from Aggro list",
        "returnType": "void"
      },
      {
        "name": "IsOnIgnoreList",
        "comment": "\n @return - If we should ignore this target altogether.",
        "returnType": "bool"
      },
      {
        "name": "ShouldAddAggroTarget",
        "comment": "\n @return - If we should aggro against this target.",
        "returnType": "bool"
      },
      {
        "name": "UpdateAggroTargets",
        "comment": "@param full -\tif a full update should be done. (expensive)\n\t\t\t\tExtended checks every target if it should still be in the aggro list.",
        "returnType": "void"
      },
      {
        "name": "RemoveInvalidAggroTargets",
        "comment": "Sweeps through all aggro entries and removes the invalid ones",
        "returnType": "void"
      },
      {
        "name": "FindAndAssignTarget",
        "comment": "Finds an appropriate target from the list of aggro targets that exist",
        "returnType": "void"
      },
      {
        "name": "SetCurrentAggroTarget",
        "comment": "Assigns a new aggrotarget",
        "returnType": "void"
      },
      {
        "name": "UpdateAggroTarget",
        "comment": "Called if we change aggro target",
        "returnType": "void"
      },
      {
        "name": "OnAggroTargetUpdated",
        "comment": "Do stuff when we found a new target",
        "returnType": "void"
      },
      {
        "name": "OnAggroTargetRemoved",
        "comment": "Do stuff when clearing the target",
        "returnType": "void"
      },
      {
        "name": "OnAggroTargetLost",
        "comment": "Called when we lose an aggro target and have no other target set",
        "returnType": "void"
      },
      {
        "name": "AddNewAggroTarget",
        "comment": "Add a new aggro target to our aggro target list, can't be in the list before",
        "returnType": "void"
      },
      {
        "name": "AddToAggroByTarget",
        "comment": "\n @param aggroTarget - The target to add aggro to.\n@param aggroToAdd - How much aggro do we want to add to the target.",
        "returnType": "void"
      },
      {
        "name": "GetAggroThreshold",
        "comment": "aggro thresholds for setting a target and releasing a target may be different",
        "returnType": "float"
      },
      {
        "name": "ShouldSwitchTarget",
        "comment": "@returns true if we should switch from our current aggro target to the new target",
        "returnType": "bool"
      },
      {
        "name": "IsValidTarget",
        "comment": "\n @param target - the target to check.\n@return - Can we have this entry as a traget.",
        "returnType": "bool"
      },
      {
        "name": "CareIfCanSeeActor",
        "comment": "\n @return - true if we care about can see target; otherwise false.",
        "returnType": "bool"
      },
      {
        "name": "CanSeeActor",
        "comment": "\n @param target - the actor we want to trace against",
        "returnType": "bool"
      },
      {
        "name": "GetMostDesirableAggroTarget",
        "comment": "Returns the aggro target that currently has the most aggro",
        "returnType": "TScriptInterface<IFGAggroTargetInterface>"
      },
      {
        "name": "GetTargetingDesire",
        "comment": "Gets targeting desire from a aggro target",
        "returnType": "float"
      },
      {
        "name": "SortMostDesirableAggroTargets",
        "comment": "function for sorting our array of aggrotargets",
        "returnType": "void"
      },
      {
        "name": "GetTargetingDesireFromAggroEntry",
        "comment": "\n @return - the targeting desire.",
        "returnType": "float"
      },
      {
        "name": "UpdateAggroTargetsAggro",
        "comment": "Updates the aggro",
        "returnType": "void"
      },
      {
        "name": "UpdateAggroTargetsIgnored",
        "comment": "Update all ignored aggro-targets and see if the ignore status can be removed.",
        "returnType": "void"
      },
      {
        "name": "UpdateAggroTargetsDistance",
        "comment": "Update desirability based on distance",
        "returnType": "void"
      },
      {
        "name": "UpdateAggroTargetsDesirabilities",
        "comment": "Update all aggro entries desirabilities.",
        "returnType": "void"
      },
      {
        "name": "GetBaseTargetingDesire",
        "comment": "@param aggroTargetIndex - the target we want to check how desirable is for us\n@return - the base disirability",
        "returnType": "float"
      },
      {
        "name": "GetDistanceTargetingDesire",
        "comment": "\n @param aggroTargetIndex - The target we want to know how desirable it is to attack\n@return -1 if something is wrong, else the desirability multiplier",
        "returnType": "float"
      },
      {
        "name": "GetAggroTargetingDesire",
        "comment": "\n @param aggroTargetIndex - The target we want to know how desirable it is to attack\n@return -1 if something is wrong, else the desirability multiplier",
        "returnType": "float"
      },
      {
        "name": "FindMostDesirableAggroTarget",
        "comment": "Finds the most desirable target based on the combination of desirabilities",
        "returnType": "TScriptInterface<IFGAggroTargetInterface>"
      },
      {
        "name": "IsIgnored",
        "comment": "\n @return - true if it is ignored.",
        "returnType": "bool"
      },
      {
        "name": "SetIgnore",
        "comment": "@param seconds - how long the target should be ignored.\n@param force - should the status update be forced.",
        "returnType": "void"
      },
      {
        "name": "SetIgnoreByIndex",
        "comment": "@param seconds - how long the target should be ignored.\n@param force - should the status update be forced.",
        "returnType": "void"
      },
      {
        "name": "GetIgnoreStatus",
        "comment": "\n @param targetIndex - if set, we will use this since it's cheaper\n@return - true if it is ignored.",
        "returnType": "EIgnore"
      },
      {
        "name": "UpdateAggroAndFindAndAssignTarget",
        "comment": "\t/\n Updates our current aggro, and then makes sure we assign a new target",
        "returnType": "void"
      },
      {
        "name": "GatherAggroTargets",
        "comment": "Gathers all aggro targets into the current list. Note, this doesn't clear the current aggro list",
        "returnType": "void"
      },
      {
        "name": "ClearAllAggroTargetsAndUpdate",
        "returnType": "void"
      },
      {
        "name": "GetAttackPatternIndex",
        "comment": "Returns index of current pattern",
        "returnType": "int32"
      },
      {
        "name": "GetCurrentAttackFromPattern",
        "comment": "Returns the attack class found in the attack pattern",
        "returnType": "TSubclassOf<UFGAttack>"
      },
      {
        "name": "UpdateAttackPattern",
        "comment": "Updates the attack from attackpattern to the next in line ( will loop )",
        "returnType": "void"
      },
      {
        "name": "GetTargetLastValidLocation",
        "comment": "Returns the last valid location for target",
        "returnType": "FVector"
      },
      {
        "name": "ResetLastValidTargetLocation",
        "comment": "Resets the variable mLastValidLocation to an invalid location",
        "returnType": "void"
      },
      {
        "name": "AggroTargetAdded",
        "comment": "Called whenever a new aggro target is added",
        "returnType": "void"
      },
      {
        "name": "AggroTargetRemoved",
        "returnType": "void"
      },
      {
        "name": "SubscribeToPawnDamage",
        "comment": "Listen for damage to our pawn",
        "returnType": "void"
      },
      {
        "name": "UnSubscribeToPawnDamage",
        "comment": "Stop listening for damage to our pawn",
        "returnType": "void"
      },
      {
        "name": "OnPawnTakeDamage",
        "comment": "Called when our controlled pawn takes damage",
        "returnType": "void"
      },
      {
        "name": "IsTargetAllowed",
        "comment": "Is this target allowed for aggro",
        "returnType": "bool"
      }
    ],
    "properties": [
      {
        "name": "mUpdateAggroHandle",
        "comment": "Handle that cares about how often we update the aggro for our AI",
        "type": "FTimerHandle"
      },
      {
        "name": "mUpdateAggroInterval",
        "comment": "Specifies how often we need to update all aggro",
        "type": "float"
      },
      {
        "name": "mTimeToLoseAllAggro",
        "comment": "How long time should it take to lose all aggro from damage",
        "type": "float"
      },
      {
        "name": "mAggroTargetsAggroMax",
        "comment": "The highest aggro for all aggro targets",
        "type": "float"
      },
      {
        "name": "mAggroBaseWeight",
        "comment": "Aggro weigths",
        "type": "float"
      },
      {
        "name": "mAggroAggroWeight",
        "type": "float"
      },
      {
        "name": "mAggroDistanceWeight",
        "type": "float"
      },
      {
        "name": "mAggroEntries",
        "comment": "All actors that this actor can aggro to",
        "type": "TArray<FAggroEntry>"
      },
      {
        "name": "mSortedAggroEntries",
        "comment": "All actors that this actor can aggro to sorted by desirability in DESC ( index 0 is most desirable)",
        "type": "TArray<FAggroEntry>"
      },
      {
        "name": "mTargetSwitchFactor",
        "comment": "We only switch mCurrentTarget if the new targets desirablility is this factor larger than the old one.",
        "type": "float"
      },
      {
        "name": "mDefaultIgnoreCooldown",
        "comment": "How long should the targets be on the ignore list",
        "type": "float"
      },
      {
        "name": "mStaticIgnoreCooldown",
        "comment": "We want static actors to be ignored a long time",
        "type": "float"
      },
      {
        "name": "mAggroDistanceCurve",
        "comment": "Curve for determining the distance aggro added",
        "type": "UCurveFloat*"
      },
      {
        "name": "mGainAggroThreshold",
        "comment": "Minimum aggro the enemy needs to add a target to its aggro list",
        "type": "float"
      },
      {
        "name": "mLoseAggroThreshold",
        "comment": "if aggro goes below this value the target is invalid",
        "type": "float"
      },
      {
        "name": "mCurrentAggroTarget",
        "comment": "This is the aggro target that at the last check was the most desirable.\nNOTE: Only set this variable through SetCurrentAggroTarget().",
        "type": "TScriptInterface<IFGAggroTargetInterface>"
      },
      {
        "name": "mMostDesirableAggroTarget",
        "comment": "The top potential aggro target",
        "type": "TScriptInterface<IFGAggroTargetInterface>"
      },
      {
        "name": "mAttackPattern",
        "comment": "Array with attacks that determine order of attacks",
        "type": "TArray<TSubclassOf<classUFGAttack>>"
      },
      {
        "name": "mAttackPatternIndex",
        "comment": "Current attack in attack pattern",
        "type": "int32"
      },
      {
        "name": "mIgnoredAggroTargetClasses",
        "comment": "List of aggro target classes that we should not aggro against",
        "type": "TArray<TSoftClassPtr<AActor>>"
      },
      {
        "name": "mLastValidLocation",
        "comment": "Last location target was seen on",
        "type": "FVector"
      },
      {
        "name": "mPanicIgnoreTime",
        "comment": "Time we should ignore targets when panicking",
        "type": "float"
      }
    ]
  }
]