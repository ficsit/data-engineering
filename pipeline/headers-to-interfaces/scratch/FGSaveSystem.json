[
  {
    "kind": "enum",
    "name": "ESaveExists",
    "entries": [
      {
        "name": "SE_DoesntExist",
        "displayName": "DoesntExist"
      },
      {
        "name": "SE_ExistsInSameSession",
        "displayName": "ExistsInSameSession"
      },
      {
        "name": "SE_ExistsInOtherSession",
        "displayName": "ExistsInOtherSession"
      }
    ]
  },
  {
    "kind": "enum",
    "name": "ESaveState",
    "entries": [
      {
        "name": "SS_Unsupported",
        "displayName": "Unsupported"
      },
      {
        "name": "SS_Volatile",
        "displayName": "Volatile"
      },
      {
        "name": "SS_Supported",
        "displayName": "Supported"
      },
      {
        "name": "SS_Newer",
        "displayName": "Newer"
      }
    ]
  },
  {
    "kind": "class",
    "name": "FSaveHeader",
    "category": "USTRUCT",
    "comment": "The header with information about a save game",
    "extends": [],
    "methods": [
      {
        "name": "FSaveHeader"
      },
      {
        "name": "FSaveHeader"
      },
      {
        "name": "operator<<",
        "comment": "Store / load data",
        "returnType": "FArchive&"
      },
      {
        "name": "NetSerialize",
        "comment": "Send/Receive over network",
        "returnType": "bool"
      }
    ],
    "properties": [
      {
        "name": "SaveVersion",
        "comment": "Version of the save game",
        "type": "int32"
      },
      {
        "name": "BuildVersion",
        "comment": "CL the game was on when this was stored",
        "type": "int32"
      },
      {
        "name": "SaveName",
        "comment": "Name of the save game, not store to disc",
        "type": "FString"
      },
      {
        "name": "MapName",
        "comment": "The map this save is valid on",
        "type": "FString"
      },
      {
        "name": "MapOptions",
        "comment": "Options we want to pass to the game mode",
        "type": "FString"
      },
      {
        "name": "SessionName",
        "comment": "A unique id for each session, used for generating autosaves that's unique",
        "type": "SessionNameType"
      },
      {
        "name": "PlayDurationSeconds",
        "comment": "How long play time has this save been going on for",
        "type": "int32"
      },
      {
        "name": "SaveDateTime",
        "comment": "The time we saved this save",
        "type": "FDateTime"
      },
      {
        "name": "SessionVisibility",
        "comment": "What was the last visibility of the game when we played it",
        "type": "TEnumAsByte<ESessionVisibility>"
      },
      {
        "name": "GUID",
        "comment": "The GUID for this custom version number",
        "type": "conststaticFGuid"
      }
    ]
  },
  {
    "kind": "class",
    "name": "TStructOpsTypeTraits",
    "comment": "Enable custom net delta serialization for the above struct.",
    "extends": [
      "TStructOpsTypeTraitsBase2"
    ],
    "methods": [],
    "properties": []
  },
  {
    "kind": "enum",
    "name": "ESaveSortMode",
    "entries": [
      {
        "name": "SSM_Name",
        "displayName": {
          "Name": true
        }
      },
      {
        "name": "SSM_Time",
        "displayName": {
          "Time": true
        }
      }
    ]
  },
  {
    "kind": "enum",
    "name": "ESaveSortDirection",
    "entries": [
      {
        "name": "SSD_Ascending",
        "displayName": {
          "Ascending": true
        }
      },
      {
        "name": "SSD_Descending",
        "displayName": {
          "Descending": true
        }
      }
    ]
  },
  {
    "kind": "class",
    "name": "FMapRedirector",
    "category": "USTRUCT",
    "comment": "For when a artist/LD has changed the name of a map",
    "extends": [],
    "methods": [],
    "properties": [
      {
        "name": "OldMapName",
        "comment": "Old map name",
        "type": "FString"
      },
      {
        "name": "NewMapName",
        "comment": "New map name",
        "type": "FString"
      }
    ]
  },
  {
    "kind": "class",
    "name": "FSessionSaveStruct",
    "category": "USTRUCT",
    "extends": [],
    "methods": [
      {
        "name": "FSessionSaveStruct"
      },
      {
        "name": "FSessionSaveStruct"
      }
    ],
    "properties": [
      {
        "name": "SessionName",
        "comment": "The name of the session",
        "type": "SessionNameType"
      },
      {
        "name": "SaveHeaders",
        "comment": "The saves that are in this session",
        "type": "TArray<FSaveHeader>"
      }
    ]
  },
  {
    "kind": "class",
    "name": "UFGSaveSystem",
    "category": "UCLASS",
    "extends": [
      "UObject"
    ],
    "methods": [
      {
        "name": "Init",
        "comment": "Initialize our save system, checks for available session ids",
        "returnType": "void"
      },
      {
        "name": "GetSaveDirectoryPath",
        "comment": "Get the path to the save folder",
        "returnType": "FString"
      },
      {
        "name": "GetUserSaveDirectoryPath",
        "comment": "Get the path to the save folder for EPIC user ID, will return path to common directory if it fails to get EPIC user ID",
        "returnType": "bool"
      },
      {
        "name": "GetCommonSaveDirectoryPath",
        "comment": "Get the path to the save folder for saves not connected to an EPIC user ID (offline play, PIE, etc)",
        "returnType": "FString"
      },
      {
        "name": "GetSourceSaveDirectoriesPaths",
        "comment": "All directories to find save data from",
        "returnType": "void"
      },
      {
        "name": "Get",
        "comment": "Get the save system from a world",
        "returnType": "classUFGSaveSystem*"
      },
      {
        "name": "Get",
        "comment": "Get the save system from a world",
        "returnType": "classUFGSaveSystem*"
      },
      {
        "name": "EnumerateSaveGames",
        "comment": "\n @param out_saveGames a list with the available save games",
        "returnType": "void"
      },
      {
        "name": "GroupSavesPerSession",
        "comment": "Groups a save list by their corresponding session",
        "returnType": "void"
      },
      {
        "name": "SortSessions",
        "comment": "Sort sessions",
        "returnType": "void"
      },
      {
        "name": "SortSaves",
        "comment": "Sort saves",
        "returnType": "void"
      },
      {
        "name": "GetSaveState",
        "comment": "Get the state we consider the save so we can warn if a save is potentially dangerous to load",
        "returnType": "ESaveState"
      },
      {
        "name": "IsSessionNameUsed",
        "returnType": "bool"
      },
      {
        "name": "AddSessionNameToUsed",
        "comment": "@todosave: Move Widget_PlayMenuAlpha::CheckSessionNameForError to native, so we can verify the error natively too",
        "returnType": "void"
      },
      {
        "name": "IsValidSaveName",
        "comment": "Helper, used to verify if the save game name is valid",
        "returnType": "bool"
      },
      {
        "name": "SaveGameExistsSync",
        "comment": "Checks on file system if the save file exists",
        "returnType": "bool"
      },
      {
        "name": "GetCachedSaveExists",
        "comment": "Check if a save game exists in the list of saves. if you don't care about session name, pass in empty currentSessionName and check != ESaveExists::SE_DoesntExist",
        "returnType": "ESaveExists"
      },
      {
        "name": "GetCachedSaves",
        "comment": "Get the last result of EnumerateSaves\nUFUNCTION( BlueprintPure, Category=\"FactoryGame|Save\")",
        "returnType": "TArray<FSaveHeader>&"
      },
      {
        "name": "DeleteSaveFiles",
        "comment": "@param completeDelegate - triggers when the file deletion is complete with the result\n@param userData - data you want passed to the complete delegate",
        "returnType": "void"
      },
      {
        "name": "GetAbsolutePathForSaveGame",
        "comment": "@param out_absoluteSaveGame - if the function returns true, then the save give outputted here\n@return true if we manage to find a valid save game",
        "returnType": "bool"
      },
      {
        "name": "CreateAbsolutePath",
        "comment": "\n @param saveName - save name without file extension\n@return the absolute path of the save",
        "returnType": "FString"
      },
      {
        "name": "SanitizeMapName",
        "comment": "Sanitize the name of the map, used when saving",
        "returnType": "FString"
      },
      {
        "name": "GenerateNewSessionName",
        "comment": "Generate a new session id and then marks it as used",
        "returnType": "SessionNameType"
      },
      {
        "name": "FindNewMapName",
        "comment": "\n @return true if the mapname was redirected",
        "returnType": "bool"
      },
      {
        "name": "FindNewClassName",
        "comment": "\n @return true if the classname was redirected",
        "returnType": "bool"
      },
      {
        "name": "FindNewObjectName",
        "comment": "\n @return true if the objectname was redirected",
        "returnType": "bool"
      },
      {
        "name": "MoveSaveFileFromCommonToEpicLocation",
        "comment": "Moves a save file present in /common/ to the currently logged in player's epic ID folder",
        "returnType": "bool"
      },
      {
        "name": "SaveFileExistsInCommonSaveDirectory",
        "returnType": "bool"
      },
      {
        "name": "SetUseBundledSaves",
        "comment": "Set so that we use our internal saves",
        "returnType": "void"
      },
      {
        "name": "IsUsingBundledSaves",
        "comment": "Return if we should use internal saves",
        "returnType": "bool"
      },
      {
        "name": "IsVerifyingSaveSystem",
        "comment": "If true, then we are in the progress of verifying the save system",
        "returnType": "bool"
      },
      {
        "name": "SetIsVerifyingSaveSystem",
        "comment": "Set if we are currently verifying the save system, @todo: This should check so that we don't switch at bad times",
        "returnType": "void"
      },
      {
        "name": "MigrateSavesToNewLocation",
        "comment": "Migrate saves to new save location",
        "returnType": "void"
      },
      {
        "name": "FindSaveGames_Internal",
        "comment": "Does the actual searching, searches on SaveLocation for save games",
        "returnType": "void"
      },
      {
        "name": "SaveNameToFileName",
        "comment": "Convert a filename with a save directory to a filename",
        "returnType": "FString"
      },
      {
        "name": "GetWorld",
        "comment": "Make sure we can get a world easily",
        "returnType": "classUWorld*"
      },
      {
        "name": "GatherUsedSaveIds",
        "comment": "Gather up used id's from saves",
        "returnType": "void"
      }
    ],
    "properties": [
      {
        "name": "mUsedSessionNames",
        "comment": "The session id's that used",
        "type": "TArray<SessionNameType>"
      },
      {
        "name": "mCachedSaves",
        "comment": "Last result of EnumerateSaves",
        "type": "TArray<FSaveHeader>"
      },
      {
        "name": "mMapRedirectors",
        "comment": "Redirects for the maps when someone renames a map",
        "type": "TArray<FMapRedirector>"
      },
      {
        "name": "mIsVerifyingSaveSystem",
        "comment": "We are currently running verification tests on the save system",
        "type": "staticbool"
      },
      {
        "name": "mIsUsingBundledSaves",
        "comment": "We are currently using internal saves",
        "type": "staticbool"
      }
    ]
  }
]